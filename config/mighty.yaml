# --------------------------------------------------------------------------
# Copyright 2024, Kota Kondo, Aerospace Controls Laboratory
# Massachusetts Institute of Technology
# All Rights Reserved
# Authors: Kota Kondo, et al.
# See LICENSE file for the license information
# --------------------------------------------------------------------------

# This is the configuration file for the mighty package
mighty_node:

    ros__parameters:

        # Vehicle type
        vehicle_type: "uav"                                     # ["uav", "ground_robot", "qudruped_robot"]
        
        # Hardware-related parameters
        provide_goal_in_global_frame: false                     # [-] Provide goal in the global frame
        use_hardware: false                                     # [-] Use hardware
        
        # Flight mode should be terminal_goal 
        flight_mode: "terminal_goal"                            # ["terminal_goal"]

        # Visual (for real-world implementation, visual should be 0)
        visual_level: 2                                         # [-] visual level (0: no visual, 1: minimal visual, 2: full visual)

        # Gloabl planner parameters
        global_planner: "sjps"                                  # ["sjps"]
        factor_dgp: 1.0                                         # do not change - [m] actual_resolution = factor_dgp * (resolution of the map)
        inflation_dgp: 0.45                                     # [m] The obstacles are inflated (to run DGP) by this amount
        x_min: -1000.0                                          # [m] x_min of the map
        x_max: 1000.0                                           # [m] x_max of the map
        y_min: -1000.0                                          # [m] y_min of the map
        y_max: 1000.0                                           # [m] y_max of the map
        z_min: 1.0                                              # [m] points below this are considered ground
        z_max: 5.0                                              # [m] DGP is run with resolution=factor_dgp*(resolution of the map)
        dgp_timeout_duration_ms: 10000                          # [ms] Timeout duration for the DGP
        use_free_start: true                                    # [-] Use free start for the DGP
        free_start_factor: 1.0                                  # [-] Factor for the free start
        use_free_goal: false                                    # [-] Use free goal for the DGP
        free_goal_factor: 2.0                                   # [-] Factor for the free goal
        global_planner_huristic_weight: 2.0         # [-] Weight for the heuristic in the global planner
        num_N: 5                                    # [-] Number of segments
        max_dist_vertexes: 3.0                      # [m] Maximum distance between two consecutive vertexes
        w_unknown: 0.0                              # [-] Weight for the unknown cells in the global planner
        w_align: 0.0                              # [-] Weight for the alignment with the initial velocity in the global planner
        decay_len_cells: 100.0                     # [-] Decay length for the alignment with the initial velocity in the global planner
        w_side: 0.0                                # [-] Weight for the side tie-break in the global planner

        # Post global path smoothing parameters
        los_cells: 3                                 # [cells] number of cells for the line-of-sight inflation for the post global path smoothing
        min_len: 1.0                               # [m] minimum length for the post global path smoothing
        min_turn: 0.0                           # [deg] minimum turn angle for the post global path smoothing

        # Decomposition module parameters
        local_box_size: [3.0, 3.0, 3.0]         # [m] Size of the local box (smaller, faster)
        min_dist_from_agent_to_traj: 10.0        # [m] Minimum distance from the agent to the trajectory
        use_shrinked_box: false                 # [-] Use shrinked box for the convex decomposition
        shrinked_box_size: 0.0                  # [m] Size of the shrinked box

        # Optimization parameters
        horizon: 15.0                               # [m] Horizon
        dc: 0.01                                    # [s] Duration for the interpolation=Value of the timer pubGoal
        v_max: 4.0                                  # [m/s]  max velocity
        a_max: 10.0                                 # [m/s2] max acceleration
        j_max: 30.0                                 # [m/s3] max jerk
        dynamic_weight: 1e+1                        # [-] Weight of the obstacles and agents distance in the optimization
        time_weight: 5e+2                           # [-] Weight of the time cost in the optimization
        pos_anchor_weight: 0.0                      # [-] Weight of the position anchors in the optimization
        stat_weight: 1e+3                           # [-] Weight of the static obstacles in the optimization
        jerk_weight: 1e-1                           # [-] Weight of the jerk in the optimization
        dyn_constr_vel_weight: 1e+3                 # [-] Weight of the velocity constraints violation in the optimization
        dyn_constr_acc_weight: 1e+3                 # [-] Weight of the acceleration constraints violation in the optimization
        dyn_constr_jerk_weight: 1e+3                # [-] Weight of the jerk constraints violation in the optimization
        dyn_constr_bodyrate_weight: 0.0             # [-] Weight of the body rate constraints violation in the optimization
        dyn_constr_tilt_weight: 0.0                 # [-] Weight of the tilt constraints violation in the optimization
        dyn_constr_thrust_weight: 0.0               # [-] Weight of the thrust constraints violation in the optimization
        num_dyn_obst_samples: 10                    # [-] Number of samples for the dynamic obstacles in the optimization
        planner_Co: 0.2                             # [-] Collision clearance thresh for static obstacles in the optimization
        planner_Cw: 3.0                             # [-] Collision clearance thresh for dynamic obstacles in the optimization
        drone_bbox: [0.2, 0.2, 0.2]                 # [m] Size of the bounding box for the obstacles
        goal_radius: 0.5                           # [m] Radius of the goal
        goal_seen_radius: 2.0                       # [m] Radius of the goal that the drone can see and stop replanning. Note that if this number is too small, the trajectory planning becomes extremely difficult.
        integral_resolution: 8
        hinge_mu: 1e-2
        omega_max: 0.10472 # [rad/s] Maximum angular velocity (6 deg/s)
        tilt_max_rad: 0.610865 # [rad] Maximum tilt angle (35 deg)
        f_min: 2.0                        # Minimum thrust
        f_max: 12.0                        # Maximum thrust
        mass: 1.0                         # [kg] Mass of the drone
        g: 9.81                        # [m/s^2] Gravitational acceleration
        fopt_threshold: 100000.0               # [-] Threshold for the fopt to consider the optimization successful

        # L-BFGS parameters
        init_turn_bf: 80.0                          # [deg] Initial turn buffer in degrees
        f_dec_coeff: 1e-3     
        cautious_factor: 1.0e-6
        past: 3
        max_linesearch: 32  
        max_iterations: 1000 
        g_epsilon: 1.0e-5
        delta: 1.0e-5

        # Dynamic obstacle parameters
        traj_lifetime: 7.0                          # [s] Time to keep the trajectory
        dynamic_obstacle_base_inflation: 0.5        # [m] Inflation for the dynamic obstacles
        max_dynamic_obstacle_inflation: 1.0         # [m] Inflation for the dynamic obstacles
        freq_dynamic_obstacle_update_to_tmap: 10.0  # [Hz] Frequency to update the dynamic obstacles to the tmap

        # Dynamic k_value parameters
        num_replanning_before_adapt: 10             # [-] Number of replanning before adapting the k_value
        default_k_value: 50                         # [-] Default k_value at the end of the trajectory
        alpha_k_value_filtering: 0.9               # [-] Alpha for the k_value adaptation
        k_value_factor: 5.0                         # [-] Factor for the k_value adaptation

        # Yaw-related parameters
        alpha_filter_dyaw: 0.1                 # [-] Filter parameter for dyaw, \in [0,1]. Higher--> More aggressive filtering
        w_max: 1.0                              # [rd/s] Maximum angular velocity. ~4.0 for Hardware
        yaw_spinning_threshold: 10000              # [-] if the planner keeps failing more than this number, we switch to the spinning mode
        yaw_spinning_dyaw: 1.0                  # [rd/s] Spinning dyaw

        # Simulation env parameters
        force_goal_z: false                     # [-] Force the goal to be at the certain height since Rviz GUI's goal's z is 0
        default_goal_z: 3.0                     # [m] Default goal height
        
        # Debug flags
        global_planner_verbose: false           # debug output
        debug_verbose: false                    # [-] Verbose the debug information
        closed_form_traj_verbose: false         # Verbosity of closed-form traj.
        verbose_computation_time: false         # [-] Verbose the computation time

        # Map parameters
        map_buffer: 1.0                         # [m] buffer for goal & A point
        center_shift_factor: 0.5                # [-] Factor for the center shift
        initial_wdx: 20.0                       # [m] Width of the map (should be the same as wdy assumed in trajCallback)
        initial_wdy: 20.0                       # [m] Depth of the map (should be the same as wdx assumed in trajCallback)
        initial_wdz: 3.0                       # [m] Height of the map
        min_wdx: 10.0                           # [m] Minimum width of the map
        min_wdy: 10.0                           # [m] Minimum depth of the map
        min_wdz: 2.0                           # [m] Minimum height of the map
        mighty_map_res: 0.15              # [m] Resolution of the map
        
        # Communication delay parameters
        use_comm_delay_inflation: true  # [-] Use communication delay inflation
        comm_delay_inflation_alpha: 0.2 # [-] Alpha for the communication delay inflation
        comm_delay_inflation_max: 0.1   # [m] Maximum communication delay inflation
        comm_delay_filter_alpha: 0.9    # [-] Alpha for the communication delay filter new_comm_delay = alpha * new_comm_delay + (1-alpha) * old_comm_delay

        # Simultation related parameters
        depth_camera_depth_max: 10.0    # [m] d435 depth in simulation
        fov_visual_depth: 10.0          # [m] FOV visual depth
        fov_visual_x_deg: 76.0          # [deg] FOV visual x degree
        fov_visual_y_deg: 47.0          # [deg] FOV visual y degree

        # Obstacle tracking/prediction parameters
        use_adaptive_kf: true                       # [-] Use adaptive KF
        adaptive_kf_alpha: 0.90                     # [-] Alpha for the adaptive KF (if you set it to 1.0, it becomes a standard KF)
        adaptive_kf_dt: 0.1                         # [s] Time step for the adaptive KF
        cluster_tolerance: 1.0                      # [m] Tolerance for the clustering
        min_cluster_size: 20                        # [-] Minimum cluster pointcloud size
        max_cluster_size: 70                       # [-] Maximum cluster pointcloud size
        prediction_horizon: 1.0                     # [s] Prediction horizon
        prediction_dt: 0.1                          # [s] Time step for the prediction
        time_to_delete_old_obstacles: 5.0           # [s] Time to delete old obstacles
        cluster_bbox_cutoff_size: 2.0               # [m] Size of the bounding box for the clustering
        use_life_time_for_box_visualization: true  # [-] Use life time for the box visualization - if false, we keep the box until the end of the simulation
        box_visualization_duration: 1.0             # [s] Duration to visualize the bounding box
        velocity_threshold: 0.8                     # [m/s] Velocity threshold to characterize as dynamic obstacles
        acceleration_threshold: 2.0                 # [m/s2] Acceleration threshold to characterize as dynamic obstacles

        # Path push visualization parameters (if we wanna visualize the path push - just flip all the flags)
        use_state_update: true                  # [-] Use ego-agent's state update - if false, we fix the ego-agent's state (this is useful for path push visualization)
        use_random_color_for_global_path: false # [-] Use random color for the global path - this is useful for path push visualization
        use_path_push_for_visualization: false  # [-] If true, we just do global planning and return true in replan() function. This is useful for the paper visualization.

        # Global planner benchmarking parameters
        use_benchmark: true                     # [-] Use global planner benchmarking
        file_path: "/media/kkondo/T7/dynus/tro_paper/global_planner_benchmarking/csv/dgp/num_0.csv" # path to the file to save the data
        use_only_global_planner: false          # [-] Use only global planner for the benchmarking

        # Initial guess parameters
        use_multiple_initial_guesses: false          # [-] Use multiple initial guesses
        num_perturbation_for_ig: 8                  # [-] Number of perturbations for the initial guess
        r_max_for_ig: 1.0                           # [m] radius for the initial guess perturbation